import React, { Component, PropTypes } from "react";
import { connect } from 'react-redux';
import {  destinationChanged,
          select_vehicle,
          hoverondesc,
          getCurrentLocation,
          get_name_of_loc,
          update_region,
          fetchPrice,
          getDistance,
          getRoute,
          calculatePrice,
          StorePrice,
          StoreKm,
          charge_method,
          StoreHr,
          getCard,
          saveScreenShot,
          getStaticImage,
          setDate,
          getNewMatch,
          setEmergency,
          change_type,
          onPayment,
        } from '../../actions/Map';
import Pulse from 'react-native-pulse';
import DateTimePicker from 'react-native-modal-datetime-picker';
import { View, Image, Dimensions, Animated, PermissionsAndroid,
  Platform, TextInput,AsyncStorage,Easing, StatusBar, TouchableWithoutFeedback, TouchableOpacity} from "react-native";
import MapView, { PROVIDER_GOOGLE } from 'react-native-maps';
//import mapStyle from './mapStyle';
import Header_Search from './header_search';
import Location from "./location_result";

//import BackgroundJob from "react-native-background-job";

//import GooglePlacesAutocomplete from 'react-native-google-places-autocomplete';
import {
  Container,
  Header,
  Title,
  Content,
  Button,
  List,
	ListItem,
  Item,
  Label,
  Input,
  Body,
  Left,
  Right,
  Icon,
  Form,
  Footer,
  FooterTab,
  Text
} from "native-base";
import isEqual from 'lodash/isEqual';
//import PushNotification from 'react-native-push-notification';
/*
compile(project(':react-native-maps')){
        exclude group: 'com.google.android.gms', module: 'play-services-base'
        exclude group: 'com.google .android.gms', module: 'play-services-maps'
    }
    compile 'com.google.android.gms:play-services-base:10.0.1'
    compile 'com.google.android.gms:play-services-maps:10.0.1'
*/
import styles from "./style";
import SearchBox from "../searchbar"
import * as Animatable from 'react-native-animatable'

const STORAGE_KEY = "user_access_token";
var { width, height } = Dimensions.get('window');
const ASPECT_RATIO = width / height;

// (Initial Static Location) Lagos Island
const LATITUDE = 6.4549;
const LONGITUDE = 3.4246;

const LATITUDE_DELTA = 0.01;
const LONGITUDE_DELTA = LATITUDE_DELTA * ASPECT_RATIO;
const USER_TOKEN = "user_token";




const regularJobKey = "regularJobKey";
const exactJobKey = "exactJobKey";
const foregroundJobKey = "foregroundJobKey";
const lol = null;

//run only on android
/*if(Platform.OS == 'android') {
  
  //const data = 0;
  // This has to run outside of the component definition since the component is never
  // instantiated when running in headless mode
  BackgroundJob.register({
    jobKey: regularJobKey,
    job: () => console.log(`Background Job fired!. Key = ${regularJobKey}`)
  });
  BackgroundJob.register({
    jobKey: exactJobKey,
    job: () => {
     //console.log(`${new Date()}Exact Job fired!. Key = ${exactJobKey}`);
      //this.props.
      //this.props.getNewMatch(this.props.user.userid);
      fetch('https://project.stackonly.com/app/api/new-order', {
        
                method: 'POST',
                  headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    id: lol,
                  })
                })
                .then((response) => response.json())
                .then((responseJson) => {
                  if (responseJson.status === 'null') {
                    //dispatch({ type: NO_NEW_MATCH, payload: true });
                    console.log("Response is "+ JSON.stringify(responseJson));
                  } else {
                    //dispatch({ type: MATCH_ALERT, payload: responseJson });
                    //dispatch({ type: NO_NEW_MATCH, payload: false });
                    //console.log(JSON.stringify(responseJson));
                    console.log("Response is "+ JSON.stringify(responseJson));
                    var dest = responseJson.user_to;
  
  
                    PushNotification.localNotification({
                      /* Android Only Properties *
                      id: '0', // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
                      ticker: "Delivery assigned", // (optional)
                      autoCancel: false, // (optional) default: true
                      largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
                      smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
                      bigText: "Delivery to "+dest+" has been assigned to a "+responseJson.driver+" "+responseJson.driver_plate_number+" "+responseJson.vehicle, // (optional) default: "message" prop
                      subText: "Delivery matched to "+responseJson.driver, // (optional) default: none
                      color: "#009AD5", // (optional) default: system default
                      vibrate: true, // (optional) default: true
                      vibration: 500, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
                      //tag: 'some_tag', // (optional) add tag to message
                      //group: "group", // (optional) add group to message
                      ongoing: false, // (optional) set whether this is an "ongoing" notification
                  
                      /* iOS only properties */
                    //  alertAction: // (optional) default: view
                    // category: // (optional) default: null
                      //userInfo: // (optional) default: null (object containing additional notification data)
                  
                      /* iOS and Android properties *
                      title: "Delivery assigned", // (optional, for iOS this is only used in apple watch, the title will be the app name on other iOS devices)
                      message: "Your delivery has been assigned", // (required)
                      playSound: false, // (optional) default: true
                      //soundName: 'default', // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. It can be set to a custom sound such as 'android.resource://com.xyz/raw/my_sound'. It will look for the 'my_sound' audio file in 'res/raw' directory and play it. default: 'default' (default sound is played)
                      number: responseJson.count, // (optional) Valid 32 bit integer specified as string. default: none (Cannot be zero)
                      //repeatType: 'day', // (Android only) Repeating interval. Could be one of `week`, `day`, `hour`, `minute, `time`. If specified as time, it should be accompanied by one more parameter 'repeatTime` which should the number of milliseconds between each interval
                      //actions: '["Call", "Message"]',  // (Android only) See the doc for notification actions to know more
                  });
  
                  }
                })
                .catch((error) => {
                  console.log("Error is "+error);
                  //dispatch({ type: MATCH_ALERT_ERROR, payload: "An error occured while getting match background" })
                })
            
  
      //console.log("DATA IS "+lol);
      //gec();
      //fool();
     
    }
  });
  
} */


class Map extends Component {
  constructor(props) {
    super(props);
    this.state = {

      region: {
      latitude: LATITUDE,
      longitude: LONGITUDE,
      latitudeDelta: LATITUDE_DELTA,
      longitudeDelta: LONGITUDE_DELTA,
    },
    bounceValue: new Animated.Value(100),
    buttonText: "GET ESTIMATE",
    isDateTimePickerVisible: false,
    mapSnapshot: null,
    map_ready: false,
    expanded: false,
    state: 'Money',
  }
  }



  _showDateTimePicker = () => this.setState({ isDateTimePickerVisible: true });

  _hideDateTimePicker = () => this.setState({ isDateTimePickerVisible: false });

  _handleDatePicked = (date) => {
    var t = new Date( date );
    //var formatted = t.format("dd.mm.yyyy hh:MM:ss");
    console.log('A date has been picked: ', t);
    this.props.setDate(date);
    this._hideDateTimePicker();
  };



  async componentWillMount() {
        
    this.animatedValue1 = new Animated.Value(0);
    this.animatedValue2 = new Animated.Value(1);
    
    this.props.fetchPrice(this.props.vehicle, this.props.emergency);
    const region = await this.props.getCurrentLocation()
    ///.then(() => {
     // this.props.update_region(this.props.region);
    //})
    //.then(() => {
    //  this.props.get_name_of_loc(this.props.latitude, this.props.longitude);
      
    //})
    
    const user = await AsyncStorage.getItem(USER_TOKEN);
    if (user !== null) {
      // We have data!!
      //console.log(JSON.parse(user));
    } else {
      try {
          await AsyncStorage.setItem(USER_TOKEN, JSON.stringify(this.props.user));
      } catch (error) {
          // Error saving data
      }
    }
  }

  componentWillUpdate() {
       
  
    if(!this.props.route_set) {
      //this.props.getCurrentLocation();
      //this.props.get_name_of_loc(this.props.latitude, this.props.longitude);
      
    } 
  }


  componentDidMount() {
   // this.props.getCurrentLocation();
   lol = this.props.user.userid;
   
    this.props.getCard(this.props.user.userid);
    if(!this.props.route_set) {
      this.props.getCurrentLocation();
      //this.props.get_name_of_loc(this.props.latitude, this.props.longitude);
      
     
    } else {
      
      this.calculatePriceThe(this.props.distanceInKM, this.props.distanceInHR, this.props.prices.per_km, this.props.prices.per_hr, this.props.prices.emergency, this.props.prices.base_price);
     }
    /* setInterval (() => {
      this.props.getNewMatch(this.props.user.userid);
      if (!this.props.no_new_match) {
        var responseJson = this.props.match_alert;
        var dest = responseJson.user_to;
        PushNotification.localNotification({
          /* Android Only Properties *
          id: '0', // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
          ticker: "Delivery assigned", // (optional)
          autoCancel: false, // (optional) default: true
          largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
          smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
          bigText: "Delivery to "+dest+" has been assigned to a "+responseJson.driver+" "+responseJson.driver_plate_number+" "+responseJson.vehicle, // (optional) default: "message" prop
          subText: "Delivery matched to "+responseJson.driver, // (optional) default: none
          color: "#009AD5", // (optional) default: system default
          vibrate: true, // (optional) default: true
          vibration: 500, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
          //tag: 'some_tag', // (optional) add tag to message
          //group: "group", // (optional) add group to message
          ongoing: false, // (optional) set whether this is an "ongoing" notification
      
          /* iOS only properties */
        //  alertAction: // (optional) default: view
        // category: // (optional) default: null
          //userInfo: // (optional) default: null (object containing additional notification data)
      
          /* iOS and Android properties *
          title: "Delivery assigned", // (optional, for iOS this is only used in apple watch, the title will be the app name on other iOS devices)
          message: "Your delivery has been assigned", // (required)
          playSound: false, // (optional) default: true
          //soundName: 'default', // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. It can be set to a custom sound such as 'android.resource://com.xyz/raw/my_sound'. It will look for the 'my_sound' audio file in 'res/raw' directory and play it. default: 'default' (default sound is played)
          number: responseJson.count, // (optional) Valid 32 bit integer specified as string. default: none (Cannot be zero)
          //repeatType: 'day', // (Android only) Repeating interval. Could be one of `week`, `day`, `hour`, `minute, `time`. If specified as time, it should be accompanied by one more parameter 'repeatTime` which should the number of milliseconds between each interval
          //actions: '["Call", "Message"]',  // (Android only) See the doc for notification actions to know more
      });

      }
      }, 10000); */

  }
  updateState(e){
    console.log(e.nativeEvent);
    this.setState({map_ready: true});
    console.log("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n The present state is "+ JSON.stringify(this.state) + "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
  }
  animateMap () {
    this._map.animateToCoordinate(tempCoords, 1);
  }
  componentWillUnmount() {
    //navigator.geolocation.clearWatch(this.watchID);
    this.props.fetchPrice(this.props.vehicle, this.props.emergency);
    
  }



  onDestChange(text) {
    this.props.destinationChanged(text);
  }

dist() {
    if (this.props.pickup !== '' && this.props.destination !== '') {
      this.props.getDistance(this.props.pickup, this.props.destination);
    }
  }
  onDestHover() {
    this.props.hoverondesc();
  }

  choose(type, emergency) {
    //const { email, password } = this.props;
    this.props.select_vehicle(type);
    this.props.fetchPrice(type, emergency);
    this.calculatePriceThe(this.props.distanceInKM, this.props.distanceInHR, this.props.prices.per_km, this.props.prices.per_hr, this.props.prices.emergency, this.props.prices.base_price);

  }


  storeToken(token) {
    AsyncStorage.removeItem(token);
    // console.log(token);
    //this.getToken();

  }

  getToken() {
    const token = AsyncStorage.getItem('user_access_token');
    console.log("TOken is "+token);

  }

   calculatePriceThe (km, hr, price_per_km, price_per_hr, emergency, base) {
        var km_num = Number(km);
        var hr_num = Number(hr/60);
        var num_price_per_km = Number(price_per_km);
        var num_price_per_hr = Number(price_per_hr);
        var num_emergency = Number(emergency);
        var num_base = Number(base);

        var price = (km_num * num_price_per_km) + (hr_num * num_price_per_hr) + num_emergency + num_base;
        //dispatch({ type: GETTING_PRICE });
        var pricee= Math.ceil(price);
        this.props.StorePrice(pricee);
        //console.log("Price is "+price);

  }


  callAnimate(t) {
    this.setState({type: t });
    if (!this.state.expanded) {
      this.setState({expanded: true});
      
      Animated.parallel([  
        Animated.timing(this.animatedValue1, {
          toValue: -150,
          duration: 250,
          easing: Easing.inOut(Easing.ease),
        }),
        Animated.timing(this.animatedValue2, {
          toValue: -190,
          duration: 250,
          easing: Easing.inOut(Easing.ease),
        }),
      ]).start();
    } else {
      this.setState({expanded: false});
      Animated.parallel([  
        Animated.timing(this.animatedValue1, {
          toValue: 0,
          duration: 250,
          easing: Easing.inOut(Easing.ease),
        }),
        Animated.timing(this.animatedValue2, {
          toValue: 0,
          duration: 250,
          easing: Easing.inOut(Easing.ease),
        }),
      ]).start();
    }
    
  }
  onSelect(type){
    this.props.charge_method(type);
    this.callAnimate('Money');
  }

  onSelect2(type){
    if (type === 'normal') {
      this.props.setEmergency(false);
      this.props.change_type('normal');
    } else {
      this.props.setEmergency(true);
      this.props.change_type('emergency');  
    }
    this.callAnimate('Life');
    
  }

  renderProps() {
    if(this.props.route_set !== false) {
      return (
      <Animatable.View animation='pulse' style={styles.map}>
        <MapView.Animated
        //provider={this.props.provider}
        ref={ref => { this.map = ref; }}
        //ref={component => this._map = component}
        customMapStyle={mapStyle}
        style={{ flex: 1,
                  zIndex: -1,
                }}
        provider={PROVIDER_GOOGLE}
        //region={this.props.region}
        region={{
          latitude: this.props.latitude,
          longitude: this.props.longitude,
          latitudeDelta: this.props.latitudeDelta * 10,
          longitudeDelta: this.props.longitudeDelta  * 10,
        }}
        //onRegionChange={this.onRegionChange.bind(this)}
        loadingEnabled={true}
        zoomEnabled={true}
        minZoomLevel={1}
        maxZoomLevel={5}
        initialRegion={{
          latitude: this.props.latitude,
          longitude: this.props.longitude,
          latitudeDelta: this.props.latitudeDelta * 10,
          longitudeDelta: this.props.longitudeDelta  * 10,
        }}
        //loadingEnabled={true}
        //showsUserLocation={true}
        //coordinates= {this.props.route}
        onMapReady ={(e) => this.updateState()}
        >
        {this.props.route_set  &&
            <MapView.Polyline
              coordinates={this.props.route}
              strokeWidth={3}
              strokeColor="#555555"
              fillColor="black"
            />
          }

            
             <MapView.Marker
               coordinate={{
                 latitude: this.props.latitude,
                 longitude: this.props.longitude,
               }}
              >
              <View style = {{
                width: 30,
                height: 30,
                borderRadius: 30,
                alignContent: 'center',
                justifyContent: 'center',
                alignItems: 'center',
                backgroundColor: '#009AD5',
              }}
                ><View style = {{
                width: 5,
                height: 5,
                borderRadius: 5,
                backgroundColor: '#FFF',
              }}
                ></View>
                </View>
                </MapView.Marker>

            {this.props.dropoff_coords.lat &&
             <MapView.Marker
                coordinate={{
                 latitude: this.props.dropoff_coords.lat,
                 longitude: this.props.dropoff_coords.lng,
                 }}
               title="Drop-off"
             >
                <View style = {{
                width: 30,
                height: 30,
                borderRadius: 30,
                alignContent: 'center',
                justifyContent: 'center',
                alignItems: 'center',
                backgroundColor: '#FFF',
              }}
                ><View style = {{
                width: 5,
                height: 5,
                borderRadius: 5,
                backgroundColor: '#888',
              }}
                ></View>
                </View>
            </MapView.Marker>
            }
      </MapView.Animated>
      </Animatable.View>
      )
    } else {
      return (
        <Animatable.View animation='bounceIn' style={styles.map}>

        <MapView.Animated
        ref={ref => { this.map = ref; }}
        onMapReady ={(e) => this.updateState()}
        
        //ref={component => this._map = component}
        customMapStyle={mapStyle}
        style={{ flex: 1,
                  zIndex: -1,
                }}
        provider={PROVIDER_GOOGLE}
        //region={this.props.region}
        region={{
          latitude: this.props.latitude,
          longitude: this.props.longitude,
          latitudeDelta: this.props.latitudeDelta,
          longitudeDelta: this.props.longitudeDelta
        }}
        onRegionChange={this.onRegionChange.bind(this)}
        loadingEnabled={true}
        zoomEnabled={true}

        initialRegion={{
          latitude: this.props.latitude,
          longitude: this.props.longitude,
          latitudeDelta: this.props.latitudeDelta,
          longitudeDelta: this.props.longitudeDelta
        }}
       >
        <MapView.Marker
        coordinate={{
        latitude: this.props.latitude,
        longitude: this.props.longitude,
        }}
        image={require('../../../img/here-pin.png')}
        //onSelect={(e) => log('onSelect', e)}  <Pulse color='blue' numPulses={1} diameter={80} speed={40} duration={2000} />
  
           // onDrag={(e) => log('onDrag', e)}
          //  onDragStart={(e) => log('onDragStart', e)}
         //   onDragEnd={this.onRegionChange.bind(this)}
        //onPress={(e) => log('onPress', e)}
        draggable
        >
        </MapView.Marker>

    </MapView.Animated>
    </Animatable.View>
      )
    }
  }

  /*setInterval (() => {
    //load = async () => {
         this.props.getCurrentLocation();
    //}
  }, 1000);
  <MapView.Marker
     draggable
      //onDragEnd={this.onUserPinDragEnd.bind(this)}
      title={'Your location'}
      onDragEnd={this.onRegionChangeCompleted.bind(this)}
      {this.props.pickup !== '' &&
        coordinate={this.props.region}
      }
      style={{opacity:1}}
    >
      <Pulse color='rgba(0, 122, 255, 0.5)' numPulses={1} diameter={100} speed={20} duration={2000} />
      <View style = {styles.marker}>
      </View>
  </MapView.Marker>
  {!this.props.hoveron &&
                  <TouchableOpacity
                     style ={styles.delivery}
                      transparent
                      onPress={this._showDateTimePicker}
                    >
                      <Icon style = {{color: '#FFF', backgroundColor: "transparent",}} name = "time"></Icon>
                    </TouchableOpacity>
                  }
   */

  onRegionChange(region) {
    this.props.update_region(region);
    this.props.get_name_of_loc(this.props.latitude, this.props.longitude)

    //console.log("This region is "+ JSON.stringify(region));
  }


  onRegionChangeCompleted(region) {
    this.props.update_region(region);
    this.props.get_name_of_loc(this.props.latitude, this.props.longitude);
  }




  getTheFuckOut() {
    this.props.onPayment(true);
    this.props.navigation.navigate('CardView');
  
}


  renderButtons() {
    if (!this.props.route_set) {

      if (this.props.vehicle === "scooter") {
        return (
          <View style = {styles.iconssRoute}>
              
              <TouchableOpacity
                style = {{
                  borderColor:'rgba(0,0,0,0.2)',
                  alignItems:'center',
                  justifyContent:'center',
                  width:70,
                  height:70,
                  backgroundColor:'#fff',
                  borderRadius:70,
                  shadowColor: '#444',
                  elevation: 2,
                  borderWidth: 1,
                  borderColor:  '#009AD5',
                  //borderBottomWidth: 1,
                  shadowOffset:{ width: 1, height: 1},
                  shadowOpacity:0.7,
                }}
                onPress={()=>this.choose('scooter', this.props.emergency)}
                
                >
                <Image  source = {require("../../../img/hitch-icon.png")}/>
              </TouchableOpacity>
               
              <TouchableOpacity
              style = {{
                borderWidth:1,
                borderColor:'rgba(0,0,0,0.2)',
                alignItems:'center',
                justifyContent:'center',
                width:70,
                height:70,
                backgroundColor:'#fff',
                borderRadius:70,
                shadowColor: '#AAA',
                elevation: 2,
                borderWidth: 1,
                borderColor:  '#CCC',
                shadowOffset:{ width: 1, height: 1},
                shadowOpacity:0.7,
                }}
                onPress = {()=>this.choose('truck', this.props.emergency)}
                >
                <Image source = {require("../../../img/taxi-icon_normal.png")}/>
              </TouchableOpacity>

          </View>
        );
      } else {
        return (
          <View style = {styles.iconssRoute}>
              <TouchableOpacity
              style = {{
                borderWidth:1,
                borderColor:'rgba(0,0,0,0.2)',
                alignItems:'center',
                justifyContent:'center',
                width:70,
                height:70,
                backgroundColor:'#fff',
                borderRadius:70,
                shadowColor: '#AAA',
                elevation: 2,
                borderColor:  '#CCC',
                borderWidth: 1,
                shadowOffset:{ width: 1, height: 1},
                shadowOpacity:0.7,
                }}
                onPress={()=>this.choose('scooter')}
                //onPress = {() => this.toggleScooter()}
                >
                <Image source = {require("../../../img/hitch-icon_normal.png")}/>
              </TouchableOpacity>

              <TouchableOpacity
              style = {{
                borderWidth:1,
                borderColor:'rgba(0,0,0,0.2)',
                alignItems:'center',
                justifyContent:'center',
                width:70,
                height:70,
                backgroundColor:'#fff',
                borderRadius:70,
                shadowColor: '#AAA',
                elevation: 2,
                borderColor:  '#009AD5',
                borderWidth: 1,
                shadowOffset:{ width: 2, height: 2},
                shadowOpacity:0.7,
                }}
                onPress = {()=>this.choose('truck')}
                >
                <Image source = {require("../../../img/taxi-icon.png")}/>
              </TouchableOpacity>
            </View>
        );
      }
    } else {

      if (this.props.vehicle === "scooter") {
        return (
          <View style = {styles.iconss}>
              <TouchableOpacity
                onPress={()=>this.choose('scooter', this.props.emergency)}
                >
                <Image style = {{marginRight: 7}} source = {require("../../../img/hitch-icon.png")}/>
              </TouchableOpacity>
              
              
              <TouchableOpacity
                onPress = {()=>this.choose('truck', this.props.emergency)}
                >
                <Image style = {{marginRight: 7}} source = {require("../../../img/taxi-icon_normal.png")}/>
              </TouchableOpacity>
              

          </View>
        );
      } else {
        return (
          <View style = {styles.iconss}>
              <TouchableOpacity
                onPress={()=>this.choose('scooter')}
                //onPress = {() => this.toggleScooter()}
                >
                <Image style = {{marginRight: 7}} source = {require("../../../img/hitch-icon_normal.png")}/>
              </TouchableOpacity>

              <TouchableOpacity
                onPress = {()=>this.choose('truck')}
                >
                <Image style = {{marginRight: 7, }} source = {require("../../../img/taxi-icon.png")}/>
              </TouchableOpacity>
            </View>
        );
      }
    }
  }


  render() {
    const animatedStyle = { 
      //height: this.animatedValue 
      transform: [
        { translateY: this.animatedValue1 },
        //{ scale: this.animatedValue2 }
      ]
    }
    const animatedStyle2 = { 
      //height: this.animatedValue 
      transform: [
        { translateY: this.animatedValue2 },
        //{ scale: this.animatedValue2 }
      ],
      opacity: this.props.hoveron ? 0 : 1,
      
        //{ scale: this.animatedValue2 }
      
    }
    return (

      <Container style={styles.container}>
        <StatusBar backgroundColor='#009AD5' barStyle='light-content' />
        
      
      
        {!this.props.hoveron ?


          this.renderProps()

            :
            <Location/>
            }
              {!this.props.hoveron &&
                <TouchableOpacity
                   style ={styles.menubar}
                    transparent onPress={() => this.props.navigation.navigate('DrawerOpen')}
                  >

                    <Image source = {menu}/>
                  </TouchableOpacity>
                }
                {!this.props.hoveron &&
                  <TouchableOpacity
                     style ={styles.delivery}
                      transparent
                      onPress={this._showDateTimePicker}
                    >

                      <Icon style = {{color: (this.props.scheduled !== null) ? '#27D9A1': '#009AD5', backgroundColor: "transparent",}} name = "time"></Icon>
                    </TouchableOpacity>

                  }

                      <Header_Search/>




      {!this.props.route_set && !this.props.hoveron  &&
        <View style = {styles.okayokay}>
        {this.renderButtons()}
          </View>
      }


      {!this.props.hoveron && this.props.route_set &&
        <View style={styles.checks}>
              <Text
                style = {{
                  textAlign: 'center',
                  color: this.props.vehicle === 'truck' ? '#27D9A1' : '#009AD5',
                  marginTop: 15,
                  fontSize: 15,
                }}>
               {this.props.vehicle.toUpperCase()}</Text>

              {this.renderButtons()}
             
              <View style = {{
                zIndex: 10,
                width: '100%',
                height: '20%',
                backgroundColor: '#FFF',
                borderColor: '#CCC',
                borderWidth: 1,
                justifyContent: 'center',
                flexDirection: 'row',
                alignItems: 'center',
            }}>
        
              <View style = {{
                  alignContent: 'center',
                  justifyContent: 'center',
                  alignItems: 'center',
                  width: '50%',
                  alignSelf: 'center',
                  padding: 5,
                  borderRightWidth: 1,
                  borderRightColor: '#CCC',

                 
                  //flexDirection: 'row',
              }}>
                <TouchableOpacity
                onPress = {() => this.callAnimate('Money')}
                style = {{
                  flexDirection: 'row',
                  
                }}>
                {this.props.charge_type == 'CASH' ?
                <Icon style = {{color: '#27D9A1', paddingRight: 10, fontSize: 20}}
                name = "cash" /> :
                <Icon style = {{color: '#009AD5', paddingRight: 10, fontSize: 20}}
                name = "card" /> }
                  <Text style = {{
                    color: '#43496A', fontSize: 17
                  }}>
                    {this.props.charge_type.toLowerCase()}    
                  </Text>
                </TouchableOpacity>
                </View>
                <View style = {{
                  alignContent: 'center',
                  justifyContent: 'center',
                  alignItems: 'center',
                  width: '50%',
                  
                  alignSelf: 'center',
                  padding: 5,
                 
                  //flexDirection: 'row',
              }}>
              <TouchableOpacity
              onPress = {() => this.callAnimate('Life')}
              style = {{
                flexDirection: 'row',
                
              }}>
              {this.props.type == 'normal' &&
              <Icon style = {{color: '#009AD5', paddingRight: 10, fontSize: 20}}
              name = "person" /> 
              }
              {this.props.type == 'scheduled' &&
              <Icon style = {{color: '#27D9A1', paddingRight: 10, fontSize: 20}}
              name = "time" /> 
              }
              {this.props.type == 'emergency' &&
              <Icon style = {{color: '#f62e2e', paddingRight: 10, fontSize: 20}}
              name = "time" /> 
              }
                <Text style = {{
                  color: '#43496A', fontSize: 17
                }}>
                  {this.props.type}    
                </Text>
              </TouchableOpacity>
                </View>
              
            </View>
            
              {(this.props.pickup !== '') && (this.props.destination !== '') &&
                  <View style={{
                    alignItems: 'center',

                  }}>
                    <Text style = {styles.continueText}>CONTINUE</Text>
                  </View>
                
              }
              {(this.props.pickup !== '') && (this.props.destination !== '') &&
                <TouchableOpacity style = {styles.continue}
                  onPress = {() => this.props.navigation.navigate('Pickup')} >
                  <View style={styles.buttonContainer}>
                    <Text style = {styles.continueText}>CONTINUE</Text>
                  </View>
                </TouchableOpacity>
              }
              {!this.props.card_exist && (this.props.charge_type === 'CARD') && this.getTheFuckOut()}
        

              <Animated.View
              animation="slideInUp"
              style={[styles.okayokayyy, animatedStyle2]}>
              {this.state.type === 'Money' ?
             
              <View style = {{
               width: '100%',
               height: '100%',
               justifyContent: 'center',
               paddingRight: 20,
               paddingLeft: 20,
               
             }}>
             <ListItem
             onPress = {() => this.onSelect('CASH')}
             >
             <Icon style = {{color: '#27D9A1', paddingRight: 10, fontSize: 20}}
                    name = "cash" /> 
                      <Text style = {{
                        color: '#43496A', fontSize: 15
                      }}> Cash 
              </Text>
             <Right>
             {this.props.charge_type == 'CASH' && <Image source = {check}/>}
             </Right>

              </ListItem>
              <ListItem
              onPress = {() => this.onSelect('CARD')}
              >
              <Icon style = {{color: '#009AD5', paddingRight: 10, fontSize: 20}}
                      name = "card" /> 
                        <Text style = {{
                          color: '#43496A', fontSize: 15
                        }}> Card 
                </Text>
              <Right>
              {this.props.charge_type == 'CARD' && <Image source = {check}/>}
              </Right>

          </ListItem>
              </View>
                :
                <View style = {{
               width: '100%',
               height: '100%',
               justifyContent: 'center',
               paddingRight: 20,
               paddingLeft: 20,
               
             }}>
             <ListItem
             onPress = {() => this.onSelect2('normal')}
             >
             <Icon style = {{color: '#27D9A1', paddingRight: 10, fontSize: 20}}
                    name = "person" /> 
                      <Text style = {{
                        color: '#43496A', fontSize: 15
                      }}> Normal 
              </Text>
             <Right>
             {this.props.type == 'normal' && <Image source = {check}/>}
             </Right>

              </ListItem>
              <ListItem
              onPress = {() => this.onSelect2('emergency')}
              >
              <Icon style = {{color: '#009AD5', paddingRight: 10, fontSize: 20}}
                      name = "time" /> 
                        <Text style = {{
                          color: '#43496A', fontSize: 15
                        }}> Emergency 
                </Text>
              <Right>
              {this.props.type == 'emergency' && <Image source = {check}/>}
              </Right>

          </ListItem>
              </View>
              }
             </Animated.View>
            </View>
            
        }
          
        
        <DateTimePicker
          mode = 'datetime'
          isVisible={this.state.isDateTimePickerVisible}
          onConfirm={this._handleDatePicked}
          onCancel={this._hideDateTimePicker}
        />

       
         

      </Container>
    );
  }
}

Map.propTypes = {
  provider: MapView.ProviderPropType,
};
const check = require("../../../img/success.png");


const trame = require("../../../img/TRAME.png");

const menu = require("../../../img/MENU.png");


mapStyle = [
  {
      "featureType": "administrative.country",
      "elementType": "geometry",
      "stylers": [
          {
              "visibility": "simplified"
          },
          {
              "hue": "#ff0000"
          }
      ]
  }
]




const mapStateToProps = ({ map }) => {
  const { destination, hoveron,
    pickup, vehicle,
    latitude,
    type,
    longitude,
    latitudeDelta,
    route,
    estimated_price,
    longitudeDelta,
    error, region,prices,charge_type,
    no_new_match,
    distanceInKM,
    card_exist,
    scheduled,
    match_alert,
    distanceInHR,
    user, dropoff_coords,loading,emergency,route_set, raw, status } = map;
  return {
    destination,
    pickup,
    vehicle,
    error,
    hoveron,
    loading,
    route,
    region,
    user,
    status,
    latitude,
    longitude,
    dropoff_coords,
    latitudeDelta,
    longitudeDelta,
    estimated_price,
    emergency,route_set,
    type,
    distanceInKM,
    scheduled,
    distanceInHR,
    prices,
    match_alert,
    charge_type,
    raw,
    no_new_match,
    card_exist,
  };
};

export default connect(mapStateToProps, {
  destinationChanged,
  getCurrentLocation,
  hoverondesc,
  select_vehicle,
  get_name_of_loc,
  update_region,
  fetchPrice,
  getDistance,
  getRoute,
  calculatePrice,
  StorePrice,
  getCard,
  setDate,
  StoreKm,
  saveScreenShot,
  charge_method,
  StoreHr,
  getStaticImage,
  getNewMatch,
  setEmergency,
  change_type,
  onPayment,

})(Map);
import React, { Component, PropTypes } from "react";
import { connect } from 'react-redux';
import FCM, {FCMEvent, RemoteNotificationResult, WillPresentNotificationResult, NotificationType} from 'react-native-fcm';
import {  destinationChanged,
          select_vehicle,
          hoverondesc,
          getCurrentLocation,
          get_name_of_loc,
          update_region,
          fetchPrice,
          getDistance,
          getRoute,
          calculatePrice,
          StorePrice,
          StoreKm,
          charge_method,
          StoreHr,
          getCard,
          saveScreenShot,
          getStaticImage,
          setDate,
          getNewMatch,
          setEmergency,
          change_type,from_where,
          onPayment,
          onChangeToken,
          network_change,
          getNewByDriver,
        } from '../../actions/Map';
import Pulse from 'react-native-pulse';
import * as firebase from "firebase";

import DateTimePicker from 'react-native-modal-datetime-picker';
import { View, Image, NetInfo,  Dimensions, Animated, PermissionsAndroid,
  Platform, TextInput,AsyncStorage,Easing, StatusBar, TouchableWithoutFeedback, TouchableOpacity} from "react-native";
import MapView, { PROVIDER_GOOGLE } from 'react-native-maps';

import Header_Search from './header_search';
import Location from "./location_result";
import {
  Container,
  Header,
  Title,
  Content,
  Button,
  List,
	ListItem,
  Item,
  Label,
  Input,
  Body,
  Left,
  Right,
  Icon,
  Form,
  Footer,
  FooterTab,
  Text
} from "native-base";
import isEqual from 'lodash/isEqual';
//import PushNotification from 'react-native-push-notification';
/*
compile(project(':react-native-maps')){
        exclude group: 'com.google.android.gms', module: 'play-services-base'
        exclude group: 'com.google .android.gms', module: 'play-services-maps'
    }
    compile 'com.google.android.gms:play-services-base:10.0.1'
    compile 'com.google.android.gms:play-services-maps:10.0.1'
*/
import styles from "./style";
import SearchBox from "../searchbar"
import * as Animatable from 'react-native-animatable'

const STORAGE_KEY = "user_access_token";
var { width, height } = Dimensions.get('window');
const ASPECT_RATIO = width / height;

// (Initial Static Location) Lagos Island
const LATITUDE = 6.4549;
const LONGITUDE = 3.4246;

const LATITUDE_DELTA = 0.01;
const LONGITUDE_DELTA = LATITUDE_DELTA * ASPECT_RATIO;
const USER_TOKEN = "user_token";

const connector = null;



//run only on android
/*if(Platform.OS == 'android') {

  //const data = 0;
  // This has to run outside of the component definition since the component is never
  // instantiated when running in headless mode
  BackgroundJob.register({
    jobKey: regularJobKey,
    job: () => console.log(`Background Job fired!. Key = ${regularJobKey}`)
  });
  BackgroundJob.register({
    jobKey: exactJobKey,
    job: () => {
     //console.log(`${new Date()}Exact Job fired!. Key = ${exactJobKey}`);
      //this.props.
      //this.props.getNewMatch(this.props.user.userid);
      fetch('https://project.stackonly.com/app/api/new-order', {

                method: 'POST',
                  headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    id: lol,
                  })
                })
                .then((response) => response.json())
                .then((responseJson) => {
                  if (responseJson.status === 'null') {
                    //dispatch({ type: NO_NEW_MATCH, payload: true });
                    console.log("Response is "+ JSON.stringify(responseJson));
                  } else {
                    //dispatch({ type: MATCH_ALERT, payload: responseJson });
                    //dispatch({ type: NO_NEW_MATCH, payload: false });
                    //console.log(JSON.stringify(responseJson));
                    console.log("Response is "+ JSON.stringify(responseJson));
                    var dest = responseJson.user_to;


                    PushNotification.localNotification({
                      /* Android Only Properties *
                      id: '0', // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
                      ticker: "Delivery assigned", // (optional)
                      autoCancel: false, // (optional) default: true
                      largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
                      smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
                      bigText: "Delivery to "+dest+" has been assigned to a "+responseJson.driver+" "+responseJson.driver_plate_number+" "+responseJson.vehicle, // (optional) default: "message" prop
                      subText: "Delivery matched to "+responseJson.driver, // (optional) default: none
                      color: "#009AD5", // (optional) default: system default
                      vibrate: true, // (optional) default: true
                      vibration: 500, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
                      //tag: 'some_tag', // (optional) add tag to message
                      //group: "group", // (optional) add group to message
                      ongoing: false, // (optional) set whether this is an "ongoing" notification

                      /* iOS only properties */
                    //  alertAction: // (optional) default: view
                    // category: // (optional) default: null
                      //userInfo: // (optional) default: null (object containing additional notification data)

                      /* iOS and Android properties *
                      title: "Delivery assigned", // (optional, for iOS this is only used in apple watch, the title will be the app name on other iOS devices)
                      message: "Your delivery has been assigned", // (required)
                      playSound: false, // (optional) default: true
                      //soundName: 'default', // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. It can be set to a custom sound such as 'android.resource://com.xyz/raw/my_sound'. It will look for the 'my_sound' audio file in 'res/raw' directory and play it. default: 'default' (default sound is played)
                      number: responseJson.count, // (optional) Valid 32 bit integer specified as string. default: none (Cannot be zero)
                      //repeatType: 'day', // (Android only) Repeating interval. Could be one of `week`, `day`, `hour`, `minute, `time`. If specified as time, it should be accompanied by one more parameter 'repeatTime` which should the number of milliseconds between each interval
                      //actions: '["Call", "Message"]',  // (Android only) See the doc for notification actions to know more
                  });

                  }
                })
                .catch((error) => {
                  console.log("Error is "+error);
                  //dispatch({ type: MATCH_ALERT_ERROR, payload: "An error occured while getting match background" })
                })


      //console.log("DATA IS "+lol);
      //gec();
      //fool();

    }
  });

} */


class Map extends Component {
  constructor(props) {
    super(props);
    
    this.state = {

      region: {
      latitude: LATITUDE,
      longitude: LONGITUDE,
      latitudeDelta: LATITUDE_DELTA,
      longitudeDelta: LONGITUDE_DELTA,
    },
    
    drivers: [],
    bounceValue: new Animated.Value(100),
    buttonText: "GET ESTIMATE",
    isDateTimePickerVisible: false,
    mapSnapshot: null,
    map_ready: false,
    expanded: false,
    state: 'Money',
    
  }
 
  }



  _showDateTimePicker = () => this.setState({ isDateTimePickerVisible: true });

  _hideDateTimePicker = () => this.setState({ isDateTimePickerVisible: false });

  _handleDatePicked = (date) => {
    var t = new Date( date );
    //var formatted = t.format("dd.mm.yyyy hh:MM:ss");
    console.log('A date has been picked: ', t);
    this.props.setDate(date);
    this._hideDateTimePicker();
  };



 async componentWillMount() {
    this.animatedValue1 = new Animated.Value(0);
    this.animatedValue2 = new Animated.Value(1);

    this.props.fetchPrice(this.props.vehicle, this.props.emergency);
    this.props.getCurrentLocation();
    this.props.from_where(false);
    if (!firebase.apps.length) {
      
    firebase.initializeApp({
      apiKey: "AIzaSyCwSgfOqkH4rr5sAll9yH9keLvWOk0VB-4",
      authDomain: "parcelfast-cdf6f.firebaseapp.com",
      databaseURL: "https://parcelfast-cdf6f.firebaseio.com",
      projectId: "parcelfast-cdf6f",
      storageBucket: "parcelfast-cdf6f.appspot.com",
      messagingSenderId: "659317790301"
    })
  }
    
    const user = await AsyncStorage.getItem(USER_TOKEN);
    if (user !== null) {
      // We have data!!
      //console.log(JSON.parse(user));
    } else {
      try {
          await AsyncStorage.setItem(USER_TOKEN, JSON.stringify(this.props.user));
      } catch (error) {
          // Error saving data
      }
    }
  }

async  componentDidMount() {
    if (!this.props.card_exist) {
      this.props.getCard(this.props.user.userid);
    }
    if(!this.props.route_set) {
      //this.props.getCurrentLocation();
      //this.props.get_name_of_loc(this.props.latitude, this.props.longitude);


    } else {

      this.calculatePriceThe(this.props.distanceInKM, this.props.distanceInHR, this.props.prices.per_km, this.props.prices.per_hr, this.props.prices.emergency, this.props.prices.base_price);
     }

     if (!this.props.hoveron){
       this.renderProps();
     }
     if (this.props.fcm_token === null) {
     try{
       let result = await FCM.requestPermissions({badge: false, sound: true, alert: true});
     } catch(e){
       console.error(e);
     }

     /*var that = this;
     //connector = firebase.database().ref();
     let qo = firebase.database().ref('adetiwa1gmailcom');
     
     var finished = [];
     qo.set({
       'latitude': 6.6018,
       'longitude': 3.3515,
       'vehicle': 'truck',
       'active': true,
       'distance': '1KM',
       'ETA': '20 mins',
       'driver_id': 3
       
     });*/
      //snapshot.forEach(function(data) {
     //q.on('value', snapshot => {
      //let result = snapshot.val();
       // console.log("Firebase DATA " +JSON.stringify(result));
        //result['key'] = data.key;

      //}).then(function() {
       /// console.log('Data receieved from firebase');
      //})
     //})
     



     FCM.getFCMToken().then(token => {
       console.log("TOKEN (getFCMToken)", token);
       this.props.onChangeToken(this.props.user.userid, token);
     });

     if(Platform.OS === 'ios'){
       FCM.getAPNSToken().then(token => {
         console.log("APNS TOKEN (getFCMToken)", token);
       });
     }

     FCM.getInitialNotification().then(notif => {
       console.log("INITIAL NOTIFICATION", notif);
       /*FCM.presentLocalNotification({
         vibrate: 500,
         title: 'Welcome Back',
         body: 'Test Notification',
         big_text: 'i am large, i am large, i am large, i am large, i am large, i am large, i am large, i am large, i am large, i am large, i am large, i am large, i am large, i am large, i am large, i am large, i am large, i am large, i am large, i am large, i am large, i am large, i am large, i am large, i am large, i am large, i am large',
         priority: "high",
         sound: "bell.mp3",
         large_icon: "https://image.freepik.com/free-icon/small-boy-cartoon_318-38077.jpg",
         show_in_foreground: true
       });*/
     });

     this.notificationListener = FCM.on(FCMEvent.Notification, notif => {
       console.log("Notification", notif);
       FCM.presentLocalNotification({
         vibrate: 500,
         title: notif.header,
         body: notif.message,
         big_text: notif.longmessage,
         priority: "high",
         sound: "bell.mp3",
         large_icon: "ic_launcher",                           // Android only
         icon: "ic_launcher",
         click_action: "ACTION",                             // as FCM payload
        // badge: 10,                                          // as FCM payload IOS only, set 0 to clear badges
        // number: 10,                                         // Android only
        ///ticker: "My Notification Ticker",
        // large_icon: "https://image.freepik.com/free-icon/small-boy-cartoon_318-38077.jpg",
         show_in_foreground: true
       });
       if(notif.local_notification){
         return;
       }
       if(notif.opened_from_tray){
         return;
       }

       if(Platform.OS ==='ios'){
               //optional
               //iOS requires developers to call completionHandler to end notification process. If you do not call it your background remote notifications could be throttled, to read more about it see the above documentation link.
               //This library handles it for you automatically with default behavior (for remote notification, finish with NoData; for WillPresent, finish depend on "show_in_foreground"). However if you want to return different result, follow the following code to override
               //notif._notificationType is available for iOS platfrom
               switch(notif._notificationType){
                 case NotificationType.Remote:
                   notif.finish(RemoteNotificationResult.NewData) //other types available: RemoteNotificationResult.NewData, RemoteNotificationResult.ResultFailed
                   break;
                 case NotificationType.NotificationResponse:
                   notif.finish();
                   break;
                 case NotificationType.WillPresent:
                   notif.finish(WillPresentNotificationResult.All) //other types available: WillPresentNotificationResult.None
                   break;
               }
       }

       this.refreshTokenListener = FCM.on(FCMEvent.RefreshToken, token => {
         console.log("TOKEN (refreshUnsubscribe)", token);
         this.props.onChangeToken(token);
       });

       // direct channel related methods are ios only
       // directly channel is truned off in iOS by default, this method enables it
       FCM.enableDirectChannel();
       this.channelConnectionListener = FCM.on(FCMEvent.DirectChannelConnectionChanged, (data) => {
         console.log('direct channel connected' + data);
       });
       setTimeout(function() {
         FCM.isDirectChannelEstablished().then(d => console.log(d));
       }, 1000);
     })

    } 
  }

  thisWillRenderTheMarkers(driver, i) {
      
    conn = firebase.database().ref('drivers').child(driver.event_id);
    //conn = firebase.database().ref('adetiwa1gmailcom');
    //conn = firebase.database().ref(driver.event_id);
    conn.on('value', snapshot => {
      let result = snapshot.val();
        if(result !== null) {
          console.log('driverid is '+ driver.driver_id +" and firebase driver id is "+ result.driver_id);
          if (driver.driver_id == result.driver_id) {
            // console.log("adding driver records to state drivers now ..."+ JSON.stringify(result)+ " and state "+ JSON.stringify(this.state));
            // debugger;
            // //check if (this car already exist)
            if(this.state.drivers.length > 0) {
              console.log("state not empty ... with size of "+this.state.drivers.length);
              
              for (i = 0; i < this.state.drivers.length; i++) {
                let dr = this.state.drivers[i].driver_id;
                let lat = this.state.drivers[i].latitude;
                let lng = this.state.drivers[i].longitude;
                let act = this.state.drivers[i].active;
                
                if (dr == result.driver_id) {
                  //only change when there is a change in data
                  if (lat != driver.latitude || lng != driver.longitude || act != driver.active) {
                      //car exist so replace
                      console.log("different data so we are changing !!!");
                      arr = this.state.drivers;
                      //arr = this.state.drivers;
                      console.log("replacing data ...");
                      result = arr[i];
                      this.setState({drivers: arr});
                      
                    
                      //this.setState(update(this.state.drivers, 
                        //{ $splice: [[i, 1, props]] }
                      //));
                    } else {
                      console.log("pushing new data ...");
                      
                      //push to drivers in state
                      this.setState({ 
                       drivers: this.state.drivers.concat([result])
                      }) //this.setState({});
                    }
                  } else {
                    console.log("same data bitch!!!");
                    
                  }
                  console.log('The state of drivers is '+ JSON.stringify(this.state.driver));
                }
            } else {
              console.log("state empty ...");
              
              this.setState({ 
                drivers: this.state.drivers.concat([result])
              }) //this.setState({});

              //console.log('The state of drivers is '+ JSON.stringify(this.state.driver));
              console.log("adding driver records to state drivers now ..."+ JSON.stringify(result)+ " and state "+ JSON.stringify(this.state));
              debugger;
              
             
            }
            
           
           
          }
        } else {
          console.log(driver.driver_name + " has no location update from firebase  or shit happened");
          
        }
      })

      console.log('The state of drivers is '+ JSON.stringify(this.state.driver));
    
  }


  theContinueButtons() {
      if ((!this.props.distance_error) && (!this.props.getting_distance) &&
      (!this.props.fetching_prices) && (!this.props.fetch_error)) {
        return (
          <TouchableOpacity style = {styles.continue}
            onPress = {() => this.props.navigation.navigate('Pickup')} >
            <View style={styles.buttonContainer}>
              <Text style = {styles.continueText}>CONTINUE</Text>
            </View>
          </TouchableOpacity>
        )
    } else if ((!this.props.distance_error)
      || (!this.props.fetch_error)) {
      return (
        <TouchableOpacity style = {styles.continue}
          disabled={true}>
            <View style={styles.buttonContainer}>
            <Text style = {styles.continueText}>please wait...</Text>
          </View>
        </TouchableOpacity>
      )
    } else if ((!this.props.getting_distance) ||
    (!this.props.fetching_prices) || (!this.props.network_connected)) {
      return (
        <View style={styles.buttonContainer}>
            <Text style = {styles.continueText}>An error occured</Text>
          </View>
      )
    }
  }


  

  componentWillUpdate() {
    
        if(!this.props.route_set) {
          //this.props.getCurrentLocation();
          if (this.props.locationGotten && !this.props.driversGotten) {
            //send location to server and get drivers around
            this.props.getNewByDriver(this.props.latitude, this.props.longitude);
            
          }
      
        }
    
        
      }
      



//handleConnectionChange = (isConnected) => {
  // this.setState({ status: isConnected });
  // this.props.network_change(isConnected);
   //console.log(`is connected: ${this.state.status}`);
//}

  onDestChange(text) {
    this.props.destinationChanged(text);
  }

dist() {
    if (this.props.pickup !== '' && this.props.destination !== '') {
      this.props.getDistance(this.props.pickup, this.props.destination);
    }
  }
  onDestHover() {
    this.props.hoverondesc();
  }

  choose(type, emergency) {
    //const { email, password } = this.props;
    this.props.select_vehicle(type);
    this.props.fetchPrice(type, emergency);
    this.calculatePriceThe(this.props.distanceInKM, this.props.distanceInHR, this.props.prices.per_km, this.props.prices.per_hr, this.props.prices.emergency, this.props.prices.base_price);

  }


  storeToken(token) {
    AsyncStorage.removeItem(token);
    // console.log(token);
    //this.getToken();

  }

  getToken() {
    const token = AsyncStorage.getItem('user_access_token');
    console.log("TOken is "+token);

  }

   calculatePriceThe (km, hr, price_per_km, price_per_hr, emergency, base) {
        var km_num = Number(km);
        var hr_num = Number(hr/60);
        var num_price_per_km = Number(price_per_km);
        var num_price_per_hr = Number(price_per_hr);
        var num_emergency = Number(emergency);
        var num_base = Number(base);

        var price = (km_num * num_price_per_km) + (hr_num * num_price_per_hr) + num_emergency + num_base;
        //dispatch({ type: GETTING_PRICE });
        var pricee= Math.ceil(price);
        this.props.StorePrice(pricee);
        //console.log("Price is "+price);

  }


  callAnimate(t) {
    this.setState({type: t });
    if (!this.state.expanded) {
      this.setState({expanded: true});

      Animated.parallel([
        Animated.timing(this.animatedValue1, {
          toValue: -150,
          duration: 250,
          easing: Easing.inOut(Easing.ease),
        }),
        Animated.timing(this.animatedValue2, {
          toValue: -190,
          duration: 250,
          easing: Easing.inOut(Easing.ease),
        }),
      ]).start();
    } else {
      this.setState({expanded: false});
      Animated.parallel([
        Animated.timing(this.animatedValue1, {
          toValue: 0,
          duration: 250,
          easing: Easing.inOut(Easing.ease),
        }),
        Animated.timing(this.animatedValue2, {
          toValue: 0,
          duration: 250,
          easing: Easing.inOut(Easing.ease),
        }),
      ]).start();
    }

  }
  onSelect(type){
    this.props.charge_method(type);
    this.callAnimate('Money');
  }

  onSelect2(type){
    if (type === 'normal') {
      this.props.setEmergency(false);
      this.props.change_type('normal');
      this.props.fetchPrice(this.props.vehicle, false);
    } else {
      this.props.setEmergency(true);
      this.props.change_type('emergency');
      this.props.fetchPrice(this.props.vehicle, true);

    }
    this.callAnimate('Life');


  }

  renderProps() {
    if(this.props.route_set !== false) {
      return (
      <Animatable.View animation='pulse' style={styles.map}>
        <MapView.Animated
        //provider={this.props.provider}
        ref={ref => { this.map = ref; }}
        //ref={component => this._map = component}
        customMapStyle={mapStyle}
        style={{ flex: 1,
                  zIndex: -1,
                }}
        provider={PROVIDER_GOOGLE}
        //region={this.props.region}
        region={{
          latitude: this.props.latitude,
          longitude: this.props.longitude,
          latitudeDelta: this.props.latitudeDelta * 10,
          longitudeDelta: this.props.longitudeDelta  * 10,
        }}
        //onRegionChange={this.onRegionChange.bind(this)}
        loadingEnabled={true}
        zoomEnabled={true}
        minZoomLevel={1}
        maxZoomLevel={5}
        initialRegion={{
          latitude: this.props.latitude,
          longitude: this.props.longitude,
          latitudeDelta: this.props.latitudeDelta * 10,
          longitudeDelta: this.props.longitudeDelta  * 10,
        }}
        //loadingEnabled={true}
        //showsUserLocation={true}
        //coordinates= {this.props.route}
        onMapReady ={(e) => this.updateState()}
        >
        {this.props.route_set  &&
            <MapView.Polyline
              coordinates={this.props.route}
              strokeWidth={3}
              strokeColor="#555555"
              fillColor="black"
            />
          }


             <MapView.Marker
               coordinate={{
                 latitude: this.props.latitude,
                 longitude: this.props.longitude,
               }}
              >
              <View style = {{
                width: 30,
                height: 30,
                borderRadius: 30,
                alignContent: 'center',
                justifyContent: 'center',
                alignItems: 'center',
                backgroundColor: '#009AD5',
              }}
                ><View style = {{
                width: 5,
                height: 5,
                borderRadius: 5,
                backgroundColor: '#FFF',
              }}
                ></View>
                </View>
                </MapView.Marker>

            {this.props.dropoff_coords.lat &&
             <MapView.Marker
                coordinate={{
                 latitude: this.props.dropoff_coords.lat,
                 longitude: this.props.dropoff_coords.lng,
                 }}
               title="Drop-off"
             >
                <View style = {{
                width: 30,
                height: 30,
                borderRadius: 30,
                alignContent: 'center',
                justifyContent: 'center',
                alignItems: 'center',
                backgroundColor: '#FFF',
              }}
                ><View style = {{
                width: 5,
                height: 5,
                borderRadius: 5,
                backgroundColor: '#888',
              }}
                ></View>
                </View>
            </MapView.Marker>
            }
      </MapView.Animated>
      </Animatable.View>
      )
    } else {
      return (
        <Animatable.View animation='bounceIn' style={styles.map}>

        <MapView.Animated
        ref={ref => { this.map = ref; }}
        onMapReady ={(e) => this.updateState()}

        //ref={component => this._map = component}
        customMapStyle={mapStyle}
        style={{ flex: 1,
                  zIndex: -1,
                }}
        provider={PROVIDER_GOOGLE}
        //region={this.props.region}
        region={{
          latitude: this.props.latitude,
          longitude: this.props.longitude,
          latitudeDelta: this.props.latitudeDelta,
          longitudeDelta: this.props.longitudeDelta
        }}
        onRegionChange={this.onRegionChange.bind(this)}
        loadingEnabled={true}
        zoomEnabled={true}

        initialRegion={{
          latitude: this.props.latitude,
          longitude: this.props.longitude,
          latitudeDelta: this.props.latitudeDelta,
          longitudeDelta: this.props.longitudeDelta
        }}
       >
        <MapView.Marker
        coordinate={{
        latitude: this.props.latitude,
        longitude: this.props.longitude,
        }}
        //image={require('../../../img/here-pin.png')}
        //onSelect={(e) => log('onSelect', e)}  <Pulse color='blue' numPulses={1} diameter={80} speed={40} duration={2000} />

           // onDrag={(e) => log('onDrag', e)}
          //  onDragStart={(e) => log('onDragStart', e)}
         //   onDragEnd={this.onRegionChange.bind(this)}
        //onPress={(e) => log('onPress', e)}
        draggable
        >
          <View style = {{
            width: 30,
            height: 30,
            borderRadius: 30,
            alignContent: 'center',
            justifyContent: 'center',
            alignItems: 'center',
            backgroundColor: '#009AD5',
          }}
            ><View style = {{
            width: 5,
            height: 5,
            borderRadius: 5,
            backgroundColor: '#FFF',
          }}
            ></View>
            </View>
        </MapView.Marker> 
        {this.props.nearbydriver !== null &&
        this.props.nearbydriver.map((driver, i) => (
          console.log("j")
         //this.thisWillRenderTheMarkers(driver, i)
        ))
        }

       {this.state.drivers.length > 0 &&
       this.state.drivers.map((driver, i) => (
         
          <MapView.Marker
              coordinate={
                { latitude: this.props.latitude,
                  longitude: this.props.longitude
                }
              }
              key={i}
              //title={marker.title}
              //image={require('../../../img/car.png')}
            >
            <View style = {{
            width: 50,
            height: 50,
            borderRadius: 50,
            alignContent: 'center',
            justifyContent: 'center',
            alignItems: 'center',
            backgroundColor: 'red',
          }}
            ><View style = {{
            width: 15,
            height: 15,
            borderRadius: 15,
            backgroundColor: '#FFF',
          }}
            ></View>
            </View>
            </MapView.Marker>
          ))
                  
      
      
      }

    </MapView.Animated>
    </Animatable.View>
      )
    }
  }


  onRegionChange(region) {
    this.props.update_region(region);
    //this.props.get_name_of_loc(this.props.latitude, this.props.longitude)

    //console.log("This region is "+ JSON.stringify(region));
  }


  onRegionChangeCompleted(region) {
    this.props.update_region(region);
    //this.props.get_name_of_loc(this.props.latitude, this.props.longitude);
  }




  getTheFuckOut() {
    this.props.onPayment(true);
    this.props.navigation.navigate('CardView');

}


  renderButtons() {
    if (!this.props.route_set) {

      if (this.props.vehicle === "scooter") {
        return (
          <View style = {styles.iconssRoute}>

              <TouchableOpacity
                style = {{
                  borderColor:'rgba(0,0,0,0.2)',
                  alignItems:'center',
                  justifyContent:'center',
                  width:70,
                  height:70,
                  backgroundColor:'#fff',
                  borderRadius:70,
                  shadowColor: '#444',
                  elevation: 2,
                  borderWidth: 2,
                  borderColor:  '#009AD5',
                  //borderBottomWidth: 1,
                  shadowOffset:{ width: 1, height: 1},
                  shadowOpacity:0.7,
                }}
                onPress={()=>this.choose('scooter', this.props.emergency)}

                >
                <Image  source = {require("../../../img/bike.png")}/>
              </TouchableOpacity>

              <TouchableOpacity
              style = {{
                borderWidth:1,
                borderColor:'rgba(0,0,0,0.2)',
                alignItems:'center',
                justifyContent:'center',
                width:70,
                height:70,
                backgroundColor:'#fff',
                borderRadius:70,
                shadowColor: '#AAA',
                elevation: 2,
                borderWidth: 1,
                borderColor:  '#CCC',
                shadowOffset:{ width: 1, height: 1},
                shadowOpacity:0.7,
                }}
                onPress = {()=>this.choose('truck', this.props.emergency)}
                >
                <Image source = {require("../../../img/car.png")}/>
              </TouchableOpacity>

          </View>
        );
      } else {
        return (
          <View style = {styles.iconssRoute}>
              <TouchableOpacity
              style = {{
                borderWidth:1,
                borderColor:'rgba(0,0,0,0.2)',
                alignItems:'center',
                justifyContent:'center',
                width:70,
                height:70,
                backgroundColor:'#fff',
                borderRadius:70,
                shadowColor: '#AAA',
                elevation: 2,
                borderColor:  '#CCC',
                borderWidth: 1,
                shadowOffset:{ width: 1, height: 1},
                shadowOpacity:0.7,
                }}
                onPress={()=>this.choose('scooter')}
                //onPress = {() => this.toggleScooter()}
                >
                <Image source = {require("../../../img/bike.png")}/>
              </TouchableOpacity>

              <TouchableOpacity
              style = {{
                borderWidth:1,
                borderColor:'rgba(0,0,0,0.2)',
                alignItems:'center',
                justifyContent:'center',
                width:70,
                height:70,
                backgroundColor:'#fff',
                borderRadius:70,
                shadowColor: '#AAA',
                elevation: 2,
                borderColor:  '#009AD5',
                borderWidth: 2,
                shadowOffset:{ width: 2, height: 2},
                shadowOpacity:0.7,
                }}
                onPress = {()=>this.choose('truck')}
                >
                <Image source = {require("../../../img/car.png")}/>
              </TouchableOpacity>
            </View>
        );
      }
    } else {

      if (this.props.vehicle === "scooter") {
        return (
          <View style = {styles.iconss}>
              <TouchableOpacity
                onPress={()=>this.choose('scooter', this.props.emergency)}
                >
                <Image style = {{marginRight: 7}} source = {require("../../../img/bike.png")}/>
              </TouchableOpacity>


              <TouchableOpacity
                onPress = {()=>this.choose('truck', this.props.emergency)}
                >
                <Image style = {{marginRight: 7}} source = {require("../../../img/car.png")}/>
              </TouchableOpacity>


          </View>
        );
      } else {
        return (
          <View style = {styles.iconss}>
              <TouchableOpacity
                onPress={()=>this.choose('scooter')}
                //onPress = {() => this.toggleScooter()}
                >
                <Image style = {{marginRight: 7}} source = {require("../../../img/bike.png")}/>
              </TouchableOpacity>

              <TouchableOpacity
                onPress = {()=>this.choose('truck')}
                >
                <Image style = {{marginRight: 7, }} source = {require("../../../img/car.png")}/>
              </TouchableOpacity>
            </View>
        );
      }
    }
  }


  render() {
    const animatedStyle = {
      //height: this.animatedValue
      transform: [
        { translateY: this.animatedValue1 },
        //{ scale: this.animatedValue2 }
      ]
    }
    const animatedStyle2 = {
      //height: this.animatedValue
      transform: [
        { translateY: this.animatedValue2 },
        //{ scale: this.animatedValue2 }
      ],
      opacity: this.props.hoveron ? 0 : 1,

        //{ scale: this.animatedValue2 }

    }
    return (

      <Container style={styles.container}>
        <StatusBar backgroundColor='#009AD5' barStyle='light-content' />



        {!this.props.hoveron ?


          this.renderProps()

            :
            <Location/>
            }
              {!this.props.hoveron &&
                <TouchableOpacity
                   style ={styles.menubar}
                    transparent onPress={() => this.props.navigation.navigate('DrawerOpen')}
                  >

                    <Image source = {menu}/>
                  </TouchableOpacity>
                }
                {!this.props.hoveron &&
                  <TouchableOpacity
                     style ={styles.delivery}
                      transparent
                      onPress={this._showDateTimePicker}
                    >

                      <Icon style = {{color: (this.props.scheduled !== null) ? '#27D9A1': '#009AD5', backgroundColor: "transparent",}} name = "time"></Icon>
                    </TouchableOpacity>

                  }

                      <Header_Search/>




      {!this.props.route_set && !this.props.hoveron  &&
        <View style = {styles.okayokay}>
        {this.renderButtons()}
          </View>
      }


      {!this.props.hoveron && this.props.route_set &&
        <View style={styles.checks}>
              <Text
                style = {{
                  textAlign: 'center',
                  color: this.props.vehicle === 'truck' ? '#27D9A1' : '#009AD5',
                  marginTop: 15,
                  fontSize: 15,
                }}>
               {this.props.vehicle.toUpperCase()}</Text>

              {this.renderButtons()}

              <View style = {{
                zIndex: 10,
                width: '100%',
                height: '20%',
                backgroundColor: '#FFF',
                borderColor: '#CCC',
                borderWidth: 1,
                justifyContent: 'center',
                flexDirection: 'row',
                alignItems: 'center',
            }}>

              <View style = {{
                  alignContent: 'center',
                  justifyContent: 'center',
                  alignItems: 'center',
                  width: '50%',
                  alignSelf: 'center',
                  padding: 5,
                  borderRightWidth: 1,
                  borderRightColor: '#CCC',


                  //flexDirection: 'row',
              }}>
                <TouchableOpacity
                onPress = {() => this.callAnimate('Money')}
                style = {{
                  flexDirection: 'row',

                }}>
                {this.props.charge_type == 'CASH' ?
                <Icon style = {{color: '#27D9A1', paddingRight: 10, fontSize: 20}}
                name = "cash" /> :
                <Icon style = {{color: '#009AD5', paddingRight: 10, fontSize: 20}}
                name = "card" /> }
                  <Text style = {{
                    color: '#43496A', fontSize: 17
                  }}>
                    {this.props.charge_type.toLowerCase()}
                  </Text>
                </TouchableOpacity>
                </View>
                <View style = {{
                  alignContent: 'center',
                  justifyContent: 'center',
                  alignItems: 'center',
                  width: '50%',

                  alignSelf: 'center',
                  padding: 5,

                  //flexDirection: 'row',
              }}>
              <TouchableOpacity
              onPress = {() => this.callAnimate('Life')}
              style = {{
                flexDirection: 'row',

              }}>
              {this.props.type == 'normal' &&
              <Icon style = {{color: '#009AD5', paddingRight: 10, fontSize: 20}}
              name = "person" />
              }
              {this.props.type == 'scheduled' &&
              <Icon style = {{color: '#27D9A1', paddingRight: 10, fontSize: 20}}
              name = "time" />
              }
              {this.props.type == 'emergency' &&
              <Icon style = {{color: '#f62e2e', paddingRight: 10, fontSize: 20}}
              name = "time" />
              }
                <Text style = {{
                  color: '#43496A', fontSize: 17
                }}>
                  {this.props.type}
                </Text>
              </TouchableOpacity>
                </View>

            </View>


              {(this.props.pickup !== '') && (this.props.destination !== '') &&
              this.theContinueButtons()
              }


              {!this.props.card_exist && (this.props.charge_type === 'CARD') && this.getTheFuckOut()}


              <Animated.View
              animation="slideInUp"
              style={[styles.okayokayyy, animatedStyle2]}>
              {this.state.type === 'Money' ?

              <View style = {{
               width: '100%',
               height: '100%',
               justifyContent: 'center',
               paddingRight: 20,
               paddingLeft: 20,

             }}>
             <ListItem
             onPress = {() => this.onSelect('CASH')}
             >
             <Icon style = {{color: '#27D9A1', paddingRight: 10, fontSize: 20}}
                    name = "cash" />
                      <Text style = {{
                        color: '#43496A', fontSize: 15
                      }}> Cash
              </Text>
             <Right>
             {this.props.charge_type == 'CASH' && <Image source = {check}/>}
             </Right>

              </ListItem>
              <ListItem
              onPress = {() => this.onSelect('CARD')}
              >
              <Icon style = {{color: '#009AD5', paddingRight: 10, fontSize: 20}}
                      name = "card" />
                        <Text style = {{
                          color: '#43496A', fontSize: 15
                        }}> Card
                </Text>
              <Right>
              {this.props.charge_type == 'CARD' && <Image source = {check}/>}
              </Right>

          </ListItem>
              </View>
                :
                <View style = {{
               width: '100%',
               height: '100%',
               justifyContent: 'center',
               paddingRight: 20,
               paddingLeft: 20,

             }}>
             <ListItem
             onPress = {() => this.onSelect2('normal')}
             >
             <Icon style = {{color: '#27D9A1', paddingRight: 10, fontSize: 20}}
                    name = "person" />
                      <Text style = {{
                        color: '#43496A', fontSize: 15
                      }}> Normal
              </Text>
             <Right>
             {this.props.type == 'normal' && <Image source = {check}/>}
             </Right>

              </ListItem>
              <ListItem
              onPress = {() => this.onSelect2('emergency')}
              >
              <Icon style = {{color: '#009AD5', paddingRight: 10, fontSize: 20}}
                      name = "time" />
                        <Text style = {{
                          color: '#43496A', fontSize: 15
                        }}> Emergency
                </Text>
              <Right>
              {this.props.type == 'emergency' && <Image source = {check}/>}
              </Right>

          </ListItem>
              </View>
              }
             </Animated.View>
            </View>

        }


        <DateTimePicker
          mode = 'datetime'
          isVisible={this.state.isDateTimePickerVisible}
          onConfirm={this._handleDatePicked}
          onCancel={this._hideDateTimePicker}
        />
               

        

      </Container>
    );
  }
}

Map.propTypes = {
  provider: MapView.ProviderPropType,
};
const check = require("../../../img/success.png");


const trame = require("../../../img/TRAME.png");

const menu = require("../../../img/MENU.png");


mapStyle = [
  {
      "featureType": "administrative.country",
      "elementType": "geometry",
      "stylers": [
          {
              "visibility": "simplified"
          },
          {
              "hue": "#ff0000"
          }
      ]
  }
]




const mapStateToProps = ({ map }) => {
  const { destination, hoveron,
    pickup, vehicle,
    latitude,
    type,
    longitude,
    latitudeDelta,
    route,
    estimated_price,
    longitudeDelta,
    error, region,prices,charge_type,
    no_new_match,
    distanceInKM,
    card_exist,
    scheduled,
    match_alert, 
    distance_error,
    network_connected,
    getting_distance,
    fetching_prices,
    fetch_error,fcm_token,
    distanceInHR,
    nearbydriver,
    locationGotten,
    driversGotten,
    user, dropoff_coords,loading,emergency,route_set, raw, status } = map;
  return {
    destination,
    pickup,
    vehicle,
    error,
    hoveron,
    loading,
    route,
    region,
    user,
    status,
    latitude,
    longitude,
    dropoff_coords,
    latitudeDelta,fcm_token,
    longitudeDelta,
    estimated_price,
    emergency,route_set,
    type,
    distanceInKM,
    scheduled,
    distanceInHR,
    prices,
    match_alert,
    network_connected,
    charge_type,
    raw,
    no_new_match,
    card_exist,
    distance_error,
    getting_distance,
    fetching_prices,
    fetch_error,
    nearbydriver,
    locationGotten,
    driversGotten,
  };
};

export default connect(mapStateToProps, {
  destinationChanged,
  getCurrentLocation,
  hoverondesc,
  select_vehicle,
  get_name_of_loc,
  update_region,
  fetchPrice,
  getDistance,
  getRoute,
  calculatePrice,
  StorePrice,
  getCard,
  setDate,
  network_change,
  StoreKm,
  saveScreenShot,
  charge_method,
  StoreHr,
  getStaticImage,
  getNewMatch,
  setEmergency,from_where,
  change_type,
  onChangeToken,
  onPayment,
  getNewByDriver

})(Map);

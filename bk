import React, { Component, PropTypes } from "react";
import { connect } from 'react-redux';
import {  destinationChanged,
          select_vehicle,
          hoverondesc,
          getCurrentLocation,
          get_name_of_loc,
          update_region,
          fetchPrice,
          getDistance,
          getRoute,
          calculatePrice,
          StorePrice,
          StoreKm,
          StoreHr,
        } from '../../actions/Map';
import Polyline from '@mapbox/polyline';
import Pulse from 'react-native-pulse';
import DateTimePicker from 'react-native-modal-datetime-picker';
import { View, Image, Dimensions, Animated,Easing, PermissionsAndroid,
  Platform, TextInput,AsyncStorage, StatusBar, TouchableWithoutFeedback, TouchableOpacity} from "react-native";
import MapView, { PROVIDER_GOOGLE } from 'react-native-maps';
//import mapStyle from './mapStyle';
import * as Animatable from 'react-native-animatable';
import Header_Search from './header_search';
import Location from "./location_result";

import BackgroundJob from "react-native-background-job";

//import GooglePlacesAutocomplete from 'react-native-google-places-autocomplete';
import {
  Container,
  Header,
  Title,
  Content,
  Button,
  Item,
  Label,
  Input,
  Body,
  Left,
  Right,
  Icon,
  Form,
  Footer,
  FooterTab,
  Text
} from "native-base";
import isEqual from 'lodash/isEqual';

import styles from "./style";
import SearchBox from "../searchbar"

const STORAGE_KEY = "user_access_token";
var { width, height } = Dimensions.get('window');
const ASPECT_RATIO = width / height;

// (Initial Static Location) Lagos Island
const LATITUDE = 6.4549;
const LONGITUDE = 3.4246;

const LATITUDE_DELTA = 0.01;
const LONGITUDE_DELTA = LATITUDE_DELTA * ASPECT_RATIO;

var isHidden = true;

const USER_TOKEN = "user_token";


const regularJobKey = "regularJobKey";
const exactJobKey = "exactJobKey";
const foregroundJobKey = "foregroundJobKey";

//run only on android
if(Platform.OS == 'android') {
  const lol = '';
  
  //const data = 0;
  // This has to run outside of the component definition since the component is never
  // instantiated when running in headless mode
  BackgroundJob.register({
    jobKey: regularJobKey,
    job: () => console.log(`Background Job fired!. Key = ${regularJobKey}`)
  });
  BackgroundJob.register({
    jobKey: exactJobKey,
    job: () => {
     //console.log(`${new Date()}Exact Job fired!. Key = ${exactJobKey}`);
      //this.props.
      //this.props.getNewMatch(this.props.user.userid);
      fetch('https://project.stackonly.com/app/api/new-order', {
        
                method: 'POST',
                  headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    id: lol,
                  })
                })
                .then((response) => response.json())
                .then((responseJson) => {
                  if (responseJson.status === 'null') {
                    //dispatch({ type: NO_NEW_MATCH, payload: true });
                    console.log("Response is "+ JSON.stringify(responseJson));
                  } else {
                    //dispatch({ type: MATCH_ALERT, payload: responseJson });
                    //dispatch({ type: NO_NEW_MATCH, payload: false });
                    //console.log(JSON.stringify(responseJson));
                    console.log("Response is "+ JSON.stringify(responseJson));
                    var dest = responseJson.user_to;
  
  
                    PushNotification.localNotification({
                      /* Android Only Properties */
                      id: '0', // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
                      ticker: "Delivery assigned", // (optional)
                      autoCancel: false, // (optional) default: true
                      largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
                      smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
                      bigText: "Delivery to "+dest+" has been assigned to a "+responseJson.driver+" "+responseJson.driver_plate_number+" "+responseJson.vehicle, // (optional) default: "message" prop
                      subText: "Delivery matched to "+responseJson.driver, // (optional) default: none
                      color: "#009AD5", // (optional) default: system default
                      vibrate: true, // (optional) default: true
                      vibration: 500, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
                      //tag: 'some_tag', // (optional) add tag to message
                      //group: "group", // (optional) add group to message
                      ongoing: false, // (optional) set whether this is an "ongoing" notification
                  
                      /* iOS only properties */
                    //  alertAction: // (optional) default: view
                    // category: // (optional) default: null
                      //userInfo: // (optional) default: null (object containing additional notification data)
                  
                      /* iOS and Android properties */
                      title: "Delivery assigned", // (optional, for iOS this is only used in apple watch, the title will be the app name on other iOS devices)
                      message: "Your delivery has been assigned", // (required)
                      playSound: false, // (optional) default: true
                      //soundName: 'default', // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. It can be set to a custom sound such as 'android.resource://com.xyz/raw/my_sound'. It will look for the 'my_sound' audio file in 'res/raw' directory and play it. default: 'default' (default sound is played)
                      number: responseJson.count, // (optional) Valid 32 bit integer specified as string. default: none (Cannot be zero)
                      //repeatType: 'day', // (Android only) Repeating interval. Could be one of `week`, `day`, `hour`, `minute, `time`. If specified as time, it should be accompanied by one more parameter 'repeatTime` which should the number of milliseconds between each interval
                      actions: '["Call", "Message"]',  // (Android only) See the doc for notification actions to know more
                  });
  
                  }
                })
                .catch((error) => {
                  console.log("Error is "+error);
                  //dispatch({ type: MATCH_ALERT_ERROR, payload: "An error occured while getting match background" })
                })
            
  
      //console.log("DATA IS "+lol);
      //gec();
      //fool();
     
    }
  });
  
}

class Map extends Component {
  constructor(props) {
    super(props);
    this.mapRef = null;
    this.state = {
      region: {
      latitude: LATITUDE,
      longitude: LONGITUDE,
      latitudeDelta: LATITUDE_DELTA,
      longitudeDelta: LONGITUDE_DELTA,
    },
    marker: {
       latitude: LATITUDE,
       longitude: LONGITUDE,
        latitudeDelta: LATITUDE_DELTA,
       longitudeDelta: LONGITUDE_DELTA,
    },
    markers: {},
    isDateTimePickerVisible: false,
    expanded: this.props.route_set ? true : false,
    selected: null,
  }
  }


  _showDateTimePicker = () => this.setState({ isDateTimePickerVisible: true });
  
    _hideDateTimePicker = () => this.setState({ isDateTimePickerVisible: false });
  
    _handleDatePicked = (date) => {
      var t = new Date( date );
      //var formatted = t.format("dd.mm.yyyy hh:MM:ss");
      console.log('A date has been picked: ', t);
      this.props.setDate(date);
      this._hideDateTimePicker();
    };
  


  createMarker(type) {
    if (type === 'pickup') {
      return {
        latitude: this.props.pickup_coords.lat,
        longitude: this.props.pickup_coords.lng,
      }
    } else {
      return {
        latitude: this.props.dropoff_coords.lat,
        longitude: this.props.dropoff_coords.lng,
      }
      
    };
  }

  
  async inputter() {
    const b = await this.calculatePriceThe(this.props.distanceInKM, this.props.distanceInHR, this.props.prices.per_km, this.props.prices.per_hr, this.props.prices.emergency, this.props.prices.base_price);
  }

  calculatePriceThe (km, hr, price_per_km, price_per_hr, emergency, base) {
    var km_num = Number(km);
    var hr_num = Number(hr/60);
    var num_price_per_km = Number(price_per_km);
    var num_price_per_hr = Number(price_per_hr);
    var num_emergency = Number(emergency);
    var num_base = Number(base);

    var price = (km_num * num_price_per_km) + (hr_num * num_price_per_hr) + num_emergency + num_base;
    //dispatch({ type: GETTING_PRICE });
    var pricee= Math.ceil(price);
    this.props.StorePrice(pricee);
    //console.log("Price is "+price);

}


  async componentWillMount() {
    this.props.fetchPrice(this.props.vehicle, this.props.emergency);
    this.props.getCurrentLocation();
    //this.props.get_name_of_loc(this.props.latitude, this.props.longitude);
    
    this.animatedValue1 = new Animated.Value(0);
    this.animatedValue2 = new Animated.Value(1);
    this.animatedValue3 = new Animated.Value(0);
    this.animatedValue4 = new Animated.Value(0);
    
    const user = await AsyncStorage.getItem(USER_TOKEN);
    if (user !== null) {
      // We have data!!
      console.log(JSON.parse(user));
    } else {
      try {
          await AsyncStorage.setItem(USER_TOKEN, JSON.stringify(this.props.user));
      } catch (error) {
      }
    }
    
  }

  componentWillUpdate() {
    if(!this.props.route_set) {
      //this.props.getCurrentLocation();
     // this.props.get_name_of_loc(this.props.latitude, this.props.longitude);
      
    }
  }

  callAnimate(data) {
    if (data === 'TRUCK') {
      if (!this.state.expanded) {
        this.setState({expanded: true});
        
        Animated.parallel([  
          Animated.timing(this.animatedValue1, {
            toValue: -150,
            duration: 250,
            easing: Easing.inOut(Easing.ease),
          }),
          Animated.timing(this.animatedValue2, {
            toValue: -190,
            duration: 250,
            easing: Easing.inOut(Easing.ease),
          }),
          Animated.timing(this.animatedValue3, {
            toValue: -80,
            duration: 250,
            easing: Easing.inOut(Easing.ease),
          }),
         
        ]).start();
      } else {
        this.setState({expanded: false});
        Animated.parallel([  
          Animated.timing(this.animatedValue3, {
            toValue: -79,
            duration: 500,
            easing: Easing.inOut(Easing.ease),
          })
        ]).start();
      }
    } else {
      if (!this.state.expanded) {
        this.setState({expanded: true});
        
        Animated.parallel([  
          Animated.timing(this.animatedValue1, {
            toValue: -150,
            duration: 250,
            easing: Easing.inOut(Easing.ease),
          }),
          Animated.timing(this.animatedValue2, {
            toValue: -190,
            duration: 250,
            easing: Easing.inOut(Easing.ease),
          }),
          Animated.timing(this.animatedValue3, {
            toValue: 60,
            duration: 250,
            easing: Easing.inOut(Easing.ease),
          }),
         
        ]).start();
      } else {
        this.setState({expanded: false});
        Animated.parallel([  
       
         
          Animated.timing(this.animatedValue3, {
            toValue: 59,
            duration: 500,
            easing: Easing.inOut(Easing.ease),
          })
          
        ]).start();
      }
    }
    
    
    this.setState({selected: data});
  }

  componentDidMount() {
    this.props.get_name_of_loc(this.props.latitude, this.props.longitude);
    this.props.fetchPrice(this.props.vehicle, this.props.emergency);
    
    if(!this.props.route_set) {
      this.props.getCurrentLocation();
     
    } else {
      
      this.calculatePriceThe(this.props.distanceInKM, this.props.distanceInHR, this.props.prices.per_km, this.props.prices.per_hr, this.props.prices.emergency, this.props.prices.base_price);
     }

  }


  componentWillUnmount() {
    this.props.fetchPrice(this.props.vehicle, this.props.emergency);
  }

  onDestChange(text) {
    this.props.destinationChanged(text);
  }

dist() {
  if (this.props.pickup !== '' && this.props.destination !== '') {
      this.props.getDistance(this.props.pickup, this.props.destination);
    }
  }
  onDestHover() {
    this.props.hoverondesc();
  }

  renderProps() {
    if(this.props.route_set !== false) {
      
      return (
        <Animatable.View animation='pulse' style={styles.map}>
        <MapView.Animated
        //provider={this.props.provider}
        ref={ref => { this.map = ref; }}
        //ref={component => this._map = component}
        customMapStyle={mapStyle}
        style={{ flex: 1,
                  zIndex: -1,
                }}
        provider={PROVIDER_GOOGLE}
        //region={this.props.region}
        region={{
          latitude: this.props.latitude,
          longitude: this.props.longitude,
          latitudeDelta: this.props.latitudeDelta * 10,
          longitudeDelta: this.props.longitudeDelta  * 10,
        }}
        //onRegionChange={this.onRegionChange.bind(this)}
        //loadingEnabled={true}
        zoomEnabled={true}
        minZoomLevel={1}
        maxZoomLevel={5}
        initialRegion={{
          latitude: this.props.latitude,
          longitude: this.props.longitude,
          latitudeDelta: this.props.latitudeDelta * 10,
          longitudeDelta: this.props.longitudeDelta  * 10,
        }}
        //loadingEnabled={true}
        //showsUserLocation={true}
        //coordinates= {this.props.route}
        >
        {this.props.route_set &&
            <MapView.Polyline
              coordinates={this.props.route}
              strokeWidth={3}
              strokeColor="#555"
              fillColor="black"
            />
          }

            
             <MapView.Marker
               coordinate={{
                 latitude: this.props.latitude,
                 longitude: this.props.longitude,
               }}
              >
              <View style = {{
                width: 20,
                height: 20,
                borderRadius: 20,
                alignContent: 'center',
                justifyContent: 'center',
                alignItems: 'center',
                backgroundColor: '#009AD5',
              }}
                ><View style = {{
                width: 5,
                height: 5,
                borderRadius: 5,
                backgroundColor: '#FFF',
              }}
                ></View>
                </View>
                </MapView.Marker>

            {this.props.dropoff_coords.lat &&
             <MapView.Marker
                coordinate={{
                 latitude: this.props.dropoff_coords.lat,
                 longitude: this.props.dropoff_coords.lng,
                 }}
               title="Drop-off"
             >
                <View style = {{
                width: 20,
                height: 20,
                //borderRadius: 30,
                alignContent: 'center',
                justifyContent: 'center',
                alignItems: 'center',
                backgroundColor: '#FFF',
              }}
                ><View style = {{
                width: 5,
                height: 5,
                borderRadius: 5,
                backgroundColor: '#009AD5',
              }}
                ></View>
                </View>
            </MapView.Marker>
            }
      </MapView.Animated>
      </Animatable.View>
      
      )
    } else {
      return (
        <Animatable.View animation='bounceIn' style={styles.map}>

        <MapView.Animated
        ref={ref => { this.map = ref; }}
        //ref={component => this._map = component}
        customMapStyle={mapStyle}
        style={{ flex: 1,
                  zIndex: -1,
                }}
        provider={PROVIDER_GOOGLE}
        //region={this.props.region}
        region={{
          latitude: this.props.latitude,
          longitude: this.props.longitude,
          latitudeDelta: this.props.latitudeDelta,
          longitudeDelta: this.props.longitudeDelta
        }}
        onRegionChange={this.onRegionChange.bind(this)}
        //loadingEnabled={true}
        zoomEnabled={true}

        initialRegion={{
          latitude: this.props.latitude,
          longitude: this.props.longitude,
          latitudeDelta: this.props.latitudeDelta,
          longitudeDelta: this.props.longitudeDelta
        }}

        //loadingEnabled={true}
        //showsUserLocation={true}
        //coordinates= {this.props.route}

      >
      
        <MapView.Marker
        coordinate={{
        latitude: this.props.latitude,
        longitude: this.props.longitude,
        }}
        image={require('../../../img/here-pin.png')}
        
        //onSelect={(e) => log('onSelect', e)}  <Pulse color='blue' numPulses={1} diameter={80} speed={40} duration={2000} />
  
           // onDrag={(e) => log('onDrag', e)}
          //  onDragStart={(e) => log('onDragStart', e)}
         //   onDragEnd={this.onRegionChange.bind(this)}
        //onPress={(e) => log('onPress', e)}
        draggable
        >
        
        </MapView.Marker>

    </MapView.Animated>
    </Animatable.View>
 
     
    
      )
    }
  }

  renderer() {
    if (this.props.route_set) {
      return (
          <View style = {{
            flex: 2.5,
            zIndex: 1000,
            width: '100%',
            backgroundColor: '#FFF',
            borderBottomColor: '#CCC',
            borderBottomWidth: 1,
            alignContent: 'center',
            justifyContent: 'center',
            flexDirection: 'column',
            alignItems: 'center',
            alignSelf: 'center',
            alignItems: 'center',
        }}>
        
        <View style = {{
            alignContent: 'center',
            justifyContent: 'center',
            alignItems: 'center',
            flex: 1,
            alignSelf: 'center',
            //flexDirection: 'row',
        }}>
          <Text style = {styles.text}>
            {this.props.distanceInKM} KM | {this.props.distanceInHR} MIN | {this.props.estimated_price} NGN ESTIMATED</Text>
          </View>

          <TouchableOpacity style = {{
            width: '100%',
            flex: 1,
            alignContent: 'center',
            alignItems: 'center',
            alignSelf: 'center',
            justifyContent: 'center',
          }}
                onPress={()=> this.callAnimate()} >
                  <View
                  style={styles.buttonContainer}
                  >
                    <Text onPress = {() => this.props.navigation.navigate('Pickup')} 
                  
                  style = {styles.continueText}>PROCEED</Text>
                  </View>
                </TouchableOpacity>
        
        
          
          </View>
      )
      
    } else {
      return (
        <View style = {{
          flex: 1.5,
          zIndex: 1000,
          width: '100%',
          backgroundColor: '#FFF',
          borderBottomColor: '#CCC',
          borderBottomWidth: 1,
          alignContent: 'center',
          justifyContent: 'center',
          flexDirection: 'column',
          alignItems: 'center',
      }}>
      
      <View style = {{
          flex: 1,
          alignContent: 'center',
          justifyContent: 'center',
          //flexDirection: 'row',
      }}>
        <Text style = {styles.text}>{this.props.prices.base_price} NGN START</Text>
        </View>


      <View style = {{
          flex: 1,
          //borderRightColor: '#CCC',
          //borderRightWidth: 1,
          alignContent: 'center',
          justifyContent: 'center',
          //flexDirection: 'row',
          
      }}>
        <Text style = {styles.text}>{this.props.prices.per_km} NGN / KM + {this.props.prices.per_hr} NGN / MIN</Text>
        </View>
      
        
        </View>
    )
    }
  }
  onRegionChange(region) {
    this.props.update_region(region);
    this.props.get_name_of_loc(this.props.latitude, this.props.longitude)

    //console.log("This region is "+ JSON.stringify(region));
  }


  onRegionChangeCompleted(region) {
    this.props.update_region(region);
    this.props.get_name_of_loc(this.props.latitude, this.props.longitude);
  }

  render() {
    const animatedStyle = { 
      //height: this.animatedValue 
      transform: [
        { translateY: this.animatedValue1 },
        { translateX: this.animatedValue3 },
        
        //{ scale: this.animatedValue2 }
      ]
    }
    const animatedStyle2 = { 
      //height: this.animatedValue 
      transform: [
        { translateY: this.animatedValue2 },
        
        //{ scale: this.animatedValue2 }
      ],
      opacity: this.props.hoveron ? 0 : 1,
      
        //{ scale: this.animatedValue2 }
      
    }
    const animatedStyle3 = { 
      //height: this.animatedValue 
      transform: [
        { translateX: this.animatedValue3 },
        
        //{ scale: this.animatedValue2 }
      ],
      opacity: this.props.hoveron ? 0 : 1,
      
        //{ scale: this.animatedValue2 }
      
    }
    const animatedStyle4 = { 
      //height: this.animatedValue 
      transform: [
        { translateX: this.animatedValue4 },
        
        //{ scale: this.animatedValue2 }
      ],
      opacity: this.props.hoveron ? 0 : 1,
      
        //{ scale: this.animatedValue2 }
      
    }
    return (

      <Container style={styles.container}>
        
        <StatusBar backgroundColor='#009AD5' barStyle='light-content' />
        {!this.props.hoveron ?

        

             this.renderProps()
            :
            <Location/>
            }
              {!this.props.hoveron &&
                <TouchableOpacity
                   style ={styles.menubar}
                    transparent onPress={() => this.props.navigation.navigate('DrawerOpen')}
                  >

                    <Image source = {menu}/>
                  </TouchableOpacity>
                }
                
                {!this.props.hoveron &&
                  <TouchableOpacity
                     style ={styles.delivery}
                      transparent
                      onPress={this._showDateTimePicker}
                    >

                      <Icon style = {{color: (this.props.scheduled === null) ? '#FFF': '#009AD5', backgroundColor: "transparent",}} name = "time"></Icon>
                    </TouchableOpacity>

                  }
                      <Header_Search/>

                      <TouchableOpacity 
                      style = {{zIndex: 1000,}}onPress = {() => this.callAnimate('TRUCK')}>
                        <Animated.View
                        style = {[{ position: 'absolute',
                        width: 60,
                        height: 60,
                        borderRadius: 60,
                        bottom: 20,
                        left: width/1.6,
                        opacity: this.props.hoveron ? 0 : 1,
                        backgroundColor: '#FFF',
                        borderColor: '#009AD5',
                        borderWidth: 3,
                        zIndex: 1000,
                        alignContent: 'center',
                        justifyContent: 'center',
                        alignItems: 'center',
                        }, animatedStyle]}>
                        <Text style = {{ alignContent: 'center',
                        justifyContent: 'center',
                        alignItems: 'center',
                        textAlign: 'center',
                        alignSelf: 'center'}}>T</Text>
                        </Animated.View>
                  </TouchableOpacity>

                  <TouchableOpacity 
                      style = {{zIndex: 1000,}}onPress = {() => this.callAnimate('SCOOTER')}>
                        <Animated.View
                        style = {[{ position: 'absolute',
                        width: 60,
                        height: 60,
                        borderRadius: 60,
                        bottom: 20,
                        left: width/4,
                        opacity: this.props.hoveron ? 0 : 1,
                        backgroundColor: '#FFF',
                        borderColor: '#009AD5',
                        borderWidth: 3,
                        zIndex: 1000,
                        alignContent: 'center',
                        justifyContent: 'center',
                        alignItems: 'center',
                        }, animatedStyle]}>
                        <Text style = {{ alignContent: 'center',
                        justifyContent: 'center',
                        alignItems: 'center',
                        textAlign: 'center',
                        alignSelf: 'center'}}>S</Text>
                        </Animated.View>
                  </TouchableOpacity>
                 
       
     
        <Animated.View
        animation="slideInUp"
        style={[styles.okayokay, animatedStyle2]}>
                
                <View style = {{
                    flex: 1,
                    borderColor: '#009AD5',
                    borderBottomColor: '#009AD5',
                    borderBottomWidth: 1,
                    alignContent: 'center',
                    justifyContent: 'center',
                    alignItems: 'center',
                    width: '100%',
                }}>
                
                <View style = {{flex: 1, alignContent: 'center',
                    justifyContent: 'center',
                    alignItems: 'center',}}><Text style = {styles.text}>{this.state.selected === null ? "PARCELFAST" : this.state.selected}</Text>
                    </View>
                  
                  </View>
                  
                  <View style = {{
                    flex: 1,
                    borderBottomColor: '#009AD5',
                    borderBottomWidth: 1,
                    alignContent: 'center',
                    justifyContent: 'center',
                    flexDirection: 'row',
                    alignItems: 'center',
                }}>

                <View style = {{
                    flex: 1,
                    borderRightColor: '#009AD5',
                    borderRightWidth: 1,
                    alignContent: 'center',
                    justifyContent: 'center',
                    //flexDirection: 'row',
                }}>
                  <Text style = {styles.text}>
                  <Icon
                   style = {{color: '#888', marginRight: 15, flex: 2, fontSize: 17}} name="time" />
                    									
                                      1 <Text style = {{color: '#888', fontSize: 12}}>MINS</Text></Text>
                  </View>


                <View style = {{
                    flex: 1,
                    //borderRightColor: '#CCC',
                    //borderRightWidth: 1,
                    alignContent: 'center',
                    justifyContent: 'center',
                    //flexDirection: 'row',
                    
                }}>
                  <Text style = {styles.text}>
                     <Icon
                   style = {{color: '#888', marginRight: 15, flex: 2, fontSize: 17}} name="person" />
                    									
                                   4  <Text style = {{color: '#888', fontSize: 12}}>SEATS</Text></Text>
                  </View>
                  
                  </View>
                  {this.renderer()}
                  

                  

              
               
               
            </Animated.View>
           
          
            <DateTimePicker
          mode = 'datetime'
          isVisible={this.state.isDateTimePickerVisible}
          onConfirm={this._handleDatePicked}
          onCancel={this._hideDateTimePicker}
        />
      </Container>
    );
  }
}
const trame = require("../../../img/TRAME.png");

const menu = require("../../../img/MENU.png");


mapStyle =  
[
    {
        "featureType": "water",
        "elementType": "geometry",
        "stylers": [
            {
                "color": "#e9e9e9"
            },
            {
                "lightness": 17
            }
        ]
    },
    {
        "featureType": "landscape",
        "elementType": "geometry",
        "stylers": [
            {
                "color": "#f5f5f5"
            },
            {
                "lightness": 20
            }
        ]
    },
    {
        "featureType": "road.highway",
        "elementType": "geometry.fill",
        "stylers": [
            {
                "color": "#ffffff"
            },
            {
                "lightness": 17
            }
        ]
    },
    {
        "featureType": "road.highway",
        "elementType": "geometry.stroke",
        "stylers": [
            {
                "color": "#ffffff"
            },
            {
                "lightness": 29
            },
            {
                "weight": 0.2
            }
        ]
    },
    {
        "featureType": "road.arterial",
        "elementType": "geometry",
        "stylers": [
            {
                "color": "#ffffff"
            },
            {
                "lightness": 18
            }
        ]
    },
    {
        "featureType": "road.local",
        "elementType": "geometry",
        "stylers": [
            {
                "color": "#ffffff"
            },
            {
                "lightness": 16
            }
        ]
    },
    {
        "featureType": "poi",
        "elementType": "geometry",
        "stylers": [
            {
                "color": "#f5f5f5"
            },
            {
                "lightness": 21
            }
        ]
    },
    {
        "featureType": "poi.park",
        "elementType": "geometry",
        "stylers": [
            {
                "color": "#dedede"
            },
            {
                "lightness": 21
            }
        ]
    },
    {
        "elementType": "labels.text.stroke",
        "stylers": [
            {
                "visibility": "on"
            },
            {
                "color": "#ffffff"
            },
            {
                "lightness": 16
            }
        ]
    },
    {
        "elementType": "labels.text.fill",
        "stylers": [
            {
                "saturation": 36
            },
            {
                "color": "#333333"
            },
            {
                "lightness": 40
            }
        ]
    },
    {
        "elementType": "labels.icon",
        "stylers": [
            {
                "visibility": "off"
            }
        ]
    },
    {
        "featureType": "transit",
        "elementType": "geometry",
        "stylers": [
            {
                "color": "#f2f2f2"
            },
            {
                "lightness": 19
            }
        ]
    },
    {
        "featureType": "administrative",
        "elementType": "geometry.fill",
        "stylers": [
            {
                "color": "#fefefe"
            },
            {
                "lightness": 20
            }
        ]
    },
    {
        "featureType": "administrative",
        "elementType": "geometry.stroke",
        "stylers": [
            {
                "color": "#fefefe"
            },
            {
                "lightness": 17
            },
            {
                "weight": 1.2
            }
        ]
    }
]

const mapStateToProps = ({ map }) => {
  const { destination, hoveron,
    pickup, vehicle,
    latitude,
    longitude,
    latitudeDelta,
    route,
    longitudeDelta,
    error, region,
    distanceInKM,
    distanceInHR, 
    prices,
    estimated_price,
    user,dropoff_coords,pickup_coords, loading,emergency,route_set, status } = map;
  return {
    destination,
    pickup,
    vehicle,
    error,
    hoveron,
    loading,
    route,
    region,
    user,
    status,
    latitude,
    distanceInKM,
    distanceInHR,
    longitude,
    latitudeDelta,
    longitudeDelta,
    dropoff_coords,
    pickup_coords,
    emergency,route_set,
    estimated_price,
    
    prices,
  };
};
export default connect(mapStateToProps, {
  destinationChanged,
  getCurrentLocation,
  hoverondesc,
  select_vehicle,
  get_name_of_loc,
  update_region,
  fetchPrice,
  getDistance,
  getRoute,
  calculatePrice,
  StorePrice,
  StoreKm,
  StoreHr,

})(Map);
